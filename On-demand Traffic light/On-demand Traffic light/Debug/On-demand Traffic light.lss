
On-demand Traffic light.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000079c  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000810  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000005  00800060  00800060  00000810  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000810  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000840  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000140  00000000  00000000  0000087c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000011ea  00000000  00000000  000009bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008d3  00000000  00000000  00001ba6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000d38  00000000  00000000  00002479  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000218  00000000  00000000  000031b4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000004e4  00000000  00000000  000033cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000007b4  00000000  00000000  000038b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d0  00000000  00000000  00004064  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 69 01 	jmp	0x2d2	; 0x2d2 <__vector_1>
   8:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  14:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  18:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  24:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  28:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  2c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  34:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  40:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
  68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
  6a:	a5 36       	cpi	r26, 0x65	; 101
  6c:	b2 07       	cpc	r27, r18
  6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
  70:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <main>
  74:	0c 94 cc 03 	jmp	0x798	; 0x798 <_exit>

00000078 <__bad_interrupt>:
  78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <APP_init>:



void APP_init()
{
	Button_init(PORT_D, 2);
  7c:	62 e0       	ldi	r22, 0x02	; 2
  7e:	84 e4       	ldi	r24, 0x44	; 68
  80:	0e 94 97 01 	call	0x32e	; 0x32e <Button_init>
	INT0_init();
  84:	0e 94 9b 01 	call	0x336	; 0x336 <INT0_init>
	LED_init(PORT_A, 0);
  88:	60 e0       	ldi	r22, 0x00	; 0
  8a:	81 e4       	ldi	r24, 0x41	; 65
  8c:	0e 94 a3 01 	call	0x346	; 0x346 <LED_init>
	LED_init(PORT_A, 1);
  90:	61 e0       	ldi	r22, 0x01	; 1
  92:	81 e4       	ldi	r24, 0x41	; 65
  94:	0e 94 a3 01 	call	0x346	; 0x346 <LED_init>
	LED_init(PORT_A, 2);
  98:	62 e0       	ldi	r22, 0x02	; 2
  9a:	81 e4       	ldi	r24, 0x41	; 65
  9c:	0e 94 a3 01 	call	0x346	; 0x346 <LED_init>
	LED_init(PORT_B, 0);
  a0:	60 e0       	ldi	r22, 0x00	; 0
  a2:	82 e4       	ldi	r24, 0x42	; 66
  a4:	0e 94 a3 01 	call	0x346	; 0x346 <LED_init>
	LED_init(PORT_B, 1);
  a8:	61 e0       	ldi	r22, 0x01	; 1
  aa:	82 e4       	ldi	r24, 0x42	; 66
  ac:	0e 94 a3 01 	call	0x346	; 0x346 <LED_init>
	LED_init(PORT_B, 2);
  b0:	62 e0       	ldi	r22, 0x02	; 2
  b2:	82 e4       	ldi	r24, 0x42	; 66
  b4:	0e 94 a3 01 	call	0x346	; 0x346 <LED_init>
  b8:	08 95       	ret

000000ba <APP_start>:
}

void APP_start()
{
	switch(state)
  ba:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <state>
  be:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <state+0x1>
  c2:	00 97       	sbiw	r24, 0x00	; 0
  c4:	21 f0       	breq	.+8      	; 0xce <APP_start+0x14>
  c6:	01 97       	sbiw	r24, 0x01	; 1
  c8:	09 f4       	brne	.+2      	; 0xcc <APP_start+0x12>
  ca:	99 c0       	rjmp	.+306    	; 0x1fe <APP_start+0x144>
  cc:	08 95       	ret
	{
		case Normal_Mode:
		ALL_LEDs_OFF();
  ce:	0e 94 b2 01 	call	0x364	; 0x364 <ALL_LEDs_OFF>
		LED_ON(PORT_A, 0);   //car green led ON
  d2:	60 e0       	ldi	r22, 0x00	; 0
  d4:	81 e4       	ldi	r24, 0x41	; 65
  d6:	0e 94 a7 01 	call	0x34e	; 0x34e <LED_ON>
		LED_ON(PORT_B, 2);   //pedestrian red led on
  da:	62 e0       	ldi	r22, 0x02	; 2
  dc:	82 e4       	ldi	r24, 0x42	; 66
  de:	0e 94 a7 01 	call	0x34e	; 0x34e <LED_ON>
		//delay for 5 sec
		for (counter = 0; counter < ON_Time; counter++)
  e2:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
  e6:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
  ea:	11 c0       	rjmp	.+34     	; 0x10e <APP_start+0x54>
		{
			if(state == 1)break;   // check interrupt
  ec:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <state>
  f0:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <state+0x1>
  f4:	01 97       	sbiw	r24, 0x01	; 1
  f6:	89 f0       	breq	.+34     	; 0x11a <APP_start+0x60>
			Delay_1s();
  f8:	0e 94 cb 01 	call	0x396	; 0x396 <Delay_1s>
		case Normal_Mode:
		ALL_LEDs_OFF();
		LED_ON(PORT_A, 0);   //car green led ON
		LED_ON(PORT_B, 2);   //pedestrian red led on
		//delay for 5 sec
		for (counter = 0; counter < ON_Time; counter++)
  fc:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 100:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 104:	01 96       	adiw	r24, 0x01	; 1
 106:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 10a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
 10e:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 112:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 116:	05 97       	sbiw	r24, 0x05	; 5
 118:	4c f3       	brlt	.-46     	; 0xec <APP_start+0x32>
			if(state == 1)break;   // check interrupt
			Delay_1s();
		}
		
		// car yellow led blinks 5 sec
		for (counter = 0; counter < ON_Time; counter++)
 11a:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 11e:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
 122:	15 c0       	rjmp	.+42     	; 0x14e <APP_start+0x94>
		{
			if(state == 1)break;   // check interrupt
 124:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <state>
 128:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <state+0x1>
 12c:	01 97       	sbiw	r24, 0x01	; 1
 12e:	a9 f0       	breq	.+42     	; 0x15a <APP_start+0xa0>
			LED_toggle(PORT_A, 1);
 130:	61 e0       	ldi	r22, 0x01	; 1
 132:	81 e4       	ldi	r24, 0x41	; 65
 134:	0e 94 af 01 	call	0x35e	; 0x35e <LED_toggle>
			Delay_1s();
 138:	0e 94 cb 01 	call	0x396	; 0x396 <Delay_1s>
			if(state == 1)break;   // check interrupt
			Delay_1s();
		}
		
		// car yellow led blinks 5 sec
		for (counter = 0; counter < ON_Time; counter++)
 13c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 140:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 144:	01 96       	adiw	r24, 0x01	; 1
 146:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 14a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
 14e:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 152:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 156:	05 97       	sbiw	r24, 0x05	; 5
 158:	2c f3       	brlt	.-54     	; 0x124 <APP_start+0x6a>
		{
			if(state == 1)break;   // check interrupt
			LED_toggle(PORT_A, 1);
			Delay_1s();
		}
		LED_OFF(PORT_A, 0);  //car green led OFF
 15a:	60 e0       	ldi	r22, 0x00	; 0
 15c:	81 e4       	ldi	r24, 0x41	; 65
 15e:	0e 94 ab 01 	call	0x356	; 0x356 <LED_OFF>
		LED_OFF(PORT_B, 2);  //pedestrian red led off
 162:	62 e0       	ldi	r22, 0x02	; 2
 164:	82 e4       	ldi	r24, 0x42	; 66
 166:	0e 94 ab 01 	call	0x356	; 0x356 <LED_OFF>
		LED_OFF(PORT_A, 1);  //car yellow led OFF
 16a:	61 e0       	ldi	r22, 0x01	; 1
 16c:	81 e4       	ldi	r24, 0x41	; 65
 16e:	0e 94 ab 01 	call	0x356	; 0x356 <LED_OFF>
		LED_ON(PORT_A, 2);  //car red led ON
 172:	62 e0       	ldi	r22, 0x02	; 2
 174:	81 e4       	ldi	r24, 0x41	; 65
 176:	0e 94 a7 01 	call	0x34e	; 0x34e <LED_ON>
		LED_ON(PORT_B, 0);  //pedestrian green led on
 17a:	60 e0       	ldi	r22, 0x00	; 0
 17c:	82 e4       	ldi	r24, 0x42	; 66
 17e:	0e 94 a7 01 	call	0x34e	; 0x34e <LED_ON>
		//delay for 5 sec
		for (counter = 0; counter < ON_Time; counter++)
 182:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 186:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
 18a:	11 c0       	rjmp	.+34     	; 0x1ae <APP_start+0xf4>
		{
			if(state == 1)break;   // check interrupt
 18c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <state>
 190:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <state+0x1>
 194:	01 97       	sbiw	r24, 0x01	; 1
 196:	89 f0       	breq	.+34     	; 0x1ba <APP_start+0x100>
			Delay_1s();
 198:	0e 94 cb 01 	call	0x396	; 0x396 <Delay_1s>
		LED_OFF(PORT_B, 2);  //pedestrian red led off
		LED_OFF(PORT_A, 1);  //car yellow led OFF
		LED_ON(PORT_A, 2);  //car red led ON
		LED_ON(PORT_B, 0);  //pedestrian green led on
		//delay for 5 sec
		for (counter = 0; counter < ON_Time; counter++)
 19c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 1a0:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 1a4:	01 96       	adiw	r24, 0x01	; 1
 1a6:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 1aa:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
 1ae:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 1b2:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 1b6:	05 97       	sbiw	r24, 0x05	; 5
 1b8:	4c f3       	brlt	.-46     	; 0x18c <APP_start+0xd2>
			if(state == 1)break;   // check interrupt
			Delay_1s();
		}
		
		// car yellow led blinks 5 sec
		for (counter = 0; counter < ON_Time; counter++)
 1ba:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 1be:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
 1c2:	16 c0       	rjmp	.+44     	; 0x1f0 <APP_start+0x136>
		{
			if(state == 1)break;   // check interrupt
 1c4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <state>
 1c8:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <state+0x1>
 1cc:	01 97       	sbiw	r24, 0x01	; 1
 1ce:	09 f4       	brne	.+2      	; 0x1d2 <APP_start+0x118>
 1d0:	7f c0       	rjmp	.+254    	; 0x2d0 <APP_start+0x216>
			LED_toggle(PORT_A, 1);
 1d2:	61 e0       	ldi	r22, 0x01	; 1
 1d4:	81 e4       	ldi	r24, 0x41	; 65
 1d6:	0e 94 af 01 	call	0x35e	; 0x35e <LED_toggle>
			Delay_1s();
 1da:	0e 94 cb 01 	call	0x396	; 0x396 <Delay_1s>
			if(state == 1)break;   // check interrupt
			Delay_1s();
		}
		
		// car yellow led blinks 5 sec
		for (counter = 0; counter < ON_Time; counter++)
 1de:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 1e2:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 1e6:	01 96       	adiw	r24, 0x01	; 1
 1e8:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 1ec:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
 1f0:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 1f4:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 1f8:	05 97       	sbiw	r24, 0x05	; 5
 1fa:	24 f3       	brlt	.-56     	; 0x1c4 <APP_start+0x10a>
 1fc:	08 95       	ret

		break;
		
		
		case Pedestrian_Mode:
		ALL_LEDs_OFF();
 1fe:	0e 94 b2 01 	call	0x364	; 0x364 <ALL_LEDs_OFF>
		if (Red_Led)  // check if red led is on
 202:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <Red_Led>
 206:	88 23       	and	r24, r24
 208:	69 f0       	breq	.+26     	; 0x224 <APP_start+0x16a>
		{
			LED_ON(PORT_A, 2);  //car red led on
 20a:	62 e0       	ldi	r22, 0x02	; 2
 20c:	81 e4       	ldi	r24, 0x41	; 65
 20e:	0e 94 a7 01 	call	0x34e	; 0x34e <LED_ON>
			LED_ON(PORT_B, 0);  //pedestrian green led on
 212:	60 e0       	ldi	r22, 0x00	; 0
 214:	82 e4       	ldi	r24, 0x42	; 66
 216:	0e 94 a7 01 	call	0x34e	; 0x34e <LED_ON>
			//delay 5 sec
			Delay(5);
 21a:	85 e0       	ldi	r24, 0x05	; 5
 21c:	90 e0       	ldi	r25, 0x00	; 0
 21e:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <Delay>
 222:	30 c0       	rjmp	.+96     	; 0x284 <APP_start+0x1ca>
		}
		else    //if car led was green or yellow
		{
			LED_ON(PORT_B, 2);  //pedestrian red led ON
 224:	62 e0       	ldi	r22, 0x02	; 2
 226:	82 e4       	ldi	r24, 0x42	; 66
 228:	0e 94 a7 01 	call	0x34e	; 0x34e <LED_ON>
			
			// both yellow LEDs blink 5 sec
			for (counter = 0; counter < ON_Time; counter++)
 22c:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 230:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
 234:	13 c0       	rjmp	.+38     	; 0x25c <APP_start+0x1a2>
			{
				LED_toggle(PORT_A, 1);  //car yellow led
 236:	61 e0       	ldi	r22, 0x01	; 1
 238:	81 e4       	ldi	r24, 0x41	; 65
 23a:	0e 94 af 01 	call	0x35e	; 0x35e <LED_toggle>
				LED_toggle(PORT_B, 1);  //pedestrian yellow led
 23e:	61 e0       	ldi	r22, 0x01	; 1
 240:	82 e4       	ldi	r24, 0x42	; 66
 242:	0e 94 af 01 	call	0x35e	; 0x35e <LED_toggle>
				Delay_1s();
 246:	0e 94 cb 01 	call	0x396	; 0x396 <Delay_1s>
		else    //if car led was green or yellow
		{
			LED_ON(PORT_B, 2);  //pedestrian red led ON
			
			// both yellow LEDs blink 5 sec
			for (counter = 0; counter < ON_Time; counter++)
 24a:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 24e:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 252:	01 96       	adiw	r24, 0x01	; 1
 254:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 258:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
 25c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 260:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 264:	05 97       	sbiw	r24, 0x05	; 5
 266:	3c f3       	brlt	.-50     	; 0x236 <APP_start+0x17c>
			{
				LED_toggle(PORT_A, 1);  //car yellow led
				LED_toggle(PORT_B, 1);  //pedestrian yellow led
				Delay_1s();
			}
			ALL_LEDs_OFF();
 268:	0e 94 b2 01 	call	0x364	; 0x364 <ALL_LEDs_OFF>
			LED_ON(PORT_A, 2);  // car red led on
 26c:	62 e0       	ldi	r22, 0x02	; 2
 26e:	81 e4       	ldi	r24, 0x41	; 65
 270:	0e 94 a7 01 	call	0x34e	; 0x34e <LED_ON>
			LED_ON(PORT_B, 0);  // pedestrian green led on
 274:	60 e0       	ldi	r22, 0x00	; 0
 276:	82 e4       	ldi	r24, 0x42	; 66
 278:	0e 94 a7 01 	call	0x34e	; 0x34e <LED_ON>
			Delay(5);   //delay 5 sec
 27c:	85 e0       	ldi	r24, 0x05	; 5
 27e:	90 e0       	ldi	r25, 0x00	; 0
 280:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <Delay>
		}
		LED_OFF(PORT_A, 2); //car red led OFF
 284:	62 e0       	ldi	r22, 0x02	; 2
 286:	81 e4       	ldi	r24, 0x41	; 65
 288:	0e 94 ab 01 	call	0x356	; 0x356 <LED_OFF>
		// both yellow LEDs blink 5 sec
		for (counter = 0; counter < ON_Time; counter++)
 28c:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 290:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
 294:	13 c0       	rjmp	.+38     	; 0x2bc <APP_start+0x202>
		{
			LED_toggle(PORT_A, 1);  //car yellow led
 296:	61 e0       	ldi	r22, 0x01	; 1
 298:	81 e4       	ldi	r24, 0x41	; 65
 29a:	0e 94 af 01 	call	0x35e	; 0x35e <LED_toggle>
			LED_toggle(PORT_B, 1);  //pedestrian yellow led
 29e:	61 e0       	ldi	r22, 0x01	; 1
 2a0:	82 e4       	ldi	r24, 0x42	; 66
 2a2:	0e 94 af 01 	call	0x35e	; 0x35e <LED_toggle>
			Delay_1s();
 2a6:	0e 94 cb 01 	call	0x396	; 0x396 <Delay_1s>
			LED_ON(PORT_B, 0);  // pedestrian green led on
			Delay(5);   //delay 5 sec
		}
		LED_OFF(PORT_A, 2); //car red led OFF
		// both yellow LEDs blink 5 sec
		for (counter = 0; counter < ON_Time; counter++)
 2aa:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 2ae:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 2b2:	01 96       	adiw	r24, 0x01	; 1
 2b4:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 2b8:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
 2bc:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 2c0:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 2c4:	05 97       	sbiw	r24, 0x05	; 5
 2c6:	3c f3       	brlt	.-50     	; 0x296 <APP_start+0x1dc>
		{
			LED_toggle(PORT_A, 1);  //car yellow led
			LED_toggle(PORT_B, 1);  //pedestrian yellow led
			Delay_1s();
		}
		state = Normal_Mode;
 2c8:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <state+0x1>
 2cc:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <state>
 2d0:	08 95       	ret

000002d2 <__vector_1>:
		break;
	}
}

ISR(INT0_vect)
{
 2d2:	1f 92       	push	r1
 2d4:	0f 92       	push	r0
 2d6:	0f b6       	in	r0, 0x3f	; 63
 2d8:	0f 92       	push	r0
 2da:	11 24       	eor	r1, r1
 2dc:	2f 93       	push	r18
 2de:	3f 93       	push	r19
 2e0:	4f 93       	push	r20
 2e2:	5f 93       	push	r21
 2e4:	6f 93       	push	r22
 2e6:	7f 93       	push	r23
 2e8:	8f 93       	push	r24
 2ea:	9f 93       	push	r25
 2ec:	af 93       	push	r26
 2ee:	bf 93       	push	r27
 2f0:	ef 93       	push	r30
 2f2:	ff 93       	push	r31
	DIO_Read(PORT_A, 2, &Red_Led);
 2f4:	44 e6       	ldi	r20, 0x64	; 100
 2f6:	50 e0       	ldi	r21, 0x00	; 0
 2f8:	62 e0       	ldi	r22, 0x02	; 2
 2fa:	81 e4       	ldi	r24, 0x41	; 65
 2fc:	0e 94 1c 03 	call	0x638	; 0x638 <DIO_Read>
	state = Pedestrian_Mode;
 300:	81 e0       	ldi	r24, 0x01	; 1
 302:	90 e0       	ldi	r25, 0x00	; 0
 304:	90 93 63 00 	sts	0x0063, r25	; 0x800063 <state+0x1>
 308:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <state>
 30c:	ff 91       	pop	r31
 30e:	ef 91       	pop	r30
 310:	bf 91       	pop	r27
 312:	af 91       	pop	r26
 314:	9f 91       	pop	r25
 316:	8f 91       	pop	r24
 318:	7f 91       	pop	r23
 31a:	6f 91       	pop	r22
 31c:	5f 91       	pop	r21
 31e:	4f 91       	pop	r20
 320:	3f 91       	pop	r19
 322:	2f 91       	pop	r18
 324:	0f 90       	pop	r0
 326:	0f be       	out	0x3f, r0	; 63
 328:	0f 90       	pop	r0
 32a:	1f 90       	pop	r1
 32c:	18 95       	reti

0000032e <Button_init>:

#include "Button.h"

void Button_init(uint8_t port_name, uint8_t pin_number)
{
	DIO_init(port_name, pin_number, INPUT);
 32e:	40 e0       	ldi	r20, 0x00	; 0
 330:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <DIO_init>
 334:	08 95       	ret

00000336 <INT0_init>:
#include "interrupts.h"

void INT0_init()
{
	//enable global interrupts
	sei();
 336:	78 94       	sei
	
	//sense on rising edge
	MCUCR |= (1<<ISC00) | (1<<ISC01);
 338:	85 b7       	in	r24, 0x35	; 53
 33a:	83 60       	ori	r24, 0x03	; 3
 33c:	85 bf       	out	0x35, r24	; 53
	
	//enable external INT0
	GICR |= (1<<INT0);
 33e:	8b b7       	in	r24, 0x3b	; 59
 340:	80 64       	ori	r24, 0x40	; 64
 342:	8b bf       	out	0x3b, r24	; 59
 344:	08 95       	ret

00000346 <LED_init>:
	DIO_toggle(port_name, pin_number);
}

void LED_State(uint8_t port_name, uint8_t pin_number, uint8_t *state)
{
	DIO_Read(port_name, pin_number, state);
 346:	41 e0       	ldi	r20, 0x01	; 1
 348:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <DIO_init>
 34c:	08 95       	ret

0000034e <LED_ON>:
 34e:	41 e0       	ldi	r20, 0x01	; 1
 350:	0e 94 8a 02 	call	0x514	; 0x514 <DIO_write>
 354:	08 95       	ret

00000356 <LED_OFF>:
 356:	40 e0       	ldi	r20, 0x00	; 0
 358:	0e 94 8a 02 	call	0x514	; 0x514 <DIO_write>
 35c:	08 95       	ret

0000035e <LED_toggle>:
 35e:	0e 94 8b 03 	call	0x716	; 0x716 <DIO_toggle>
 362:	08 95       	ret

00000364 <ALL_LEDs_OFF>:
}

void ALL_LEDs_OFF()
{
	LED_OFF(PORT_A, 0);  //car green led
 364:	60 e0       	ldi	r22, 0x00	; 0
 366:	81 e4       	ldi	r24, 0x41	; 65
 368:	0e 94 ab 01 	call	0x356	; 0x356 <LED_OFF>
	LED_OFF(PORT_A, 1);  //car yellow led
 36c:	61 e0       	ldi	r22, 0x01	; 1
 36e:	81 e4       	ldi	r24, 0x41	; 65
 370:	0e 94 ab 01 	call	0x356	; 0x356 <LED_OFF>
	LED_OFF(PORT_A, 2);  //car red led
 374:	62 e0       	ldi	r22, 0x02	; 2
 376:	81 e4       	ldi	r24, 0x41	; 65
 378:	0e 94 ab 01 	call	0x356	; 0x356 <LED_OFF>
	
	LED_OFF(PORT_B, 0);  //pedestrian green led
 37c:	60 e0       	ldi	r22, 0x00	; 0
 37e:	82 e4       	ldi	r24, 0x42	; 66
 380:	0e 94 ab 01 	call	0x356	; 0x356 <LED_OFF>
	LED_OFF(PORT_B, 1);  //pedestrian yellow led
 384:	61 e0       	ldi	r22, 0x01	; 1
 386:	82 e4       	ldi	r24, 0x42	; 66
 388:	0e 94 ab 01 	call	0x356	; 0x356 <LED_OFF>
	LED_OFF(PORT_B, 2);  //pedestrian red led	
 38c:	62 e0       	ldi	r22, 0x02	; 2
 38e:	82 e4       	ldi	r24, 0x42	; 66
 390:	0e 94 ab 01 	call	0x356	; 0x356 <LED_OFF>
 394:	08 95       	ret

00000396 <Delay_1s>:

void Delay_1s()
{
	unsigned int overflowNum = 62;
	//setting timer to normal mode
	TCCR0 = 0x00;
 396:	13 be       	out	0x33, r1	; 51
	//setting initial value to 4
	TCNT0 = (1<<2);
 398:	84 e0       	ldi	r24, 0x04	; 4
 39a:	82 bf       	out	0x32, r24	; 50
	//clkI/O/64 (From prescaler)
	TCCR0 |= 0x03;
 39c:	83 b7       	in	r24, 0x33	; 51
 39e:	83 60       	ori	r24, 0x03	; 3
 3a0:	83 bf       	out	0x33, r24	; 51
	for (int i = 0; i < overflowNum; i++)
 3a2:	20 e0       	ldi	r18, 0x00	; 0
 3a4:	30 e0       	ldi	r19, 0x00	; 0
 3a6:	08 c0       	rjmp	.+16     	; 0x3b8 <Delay_1s+0x22>
	{
		//wait until overflow flag to be set
		while((TIFR & (1<<0)) == 0);
 3a8:	08 b6       	in	r0, 0x38	; 56
 3aa:	00 fe       	sbrs	r0, 0
 3ac:	fd cf       	rjmp	.-6      	; 0x3a8 <Delay_1s+0x12>
		//clear overflow flag
		TIFR |= (1<<0);
 3ae:	88 b7       	in	r24, 0x38	; 56
 3b0:	81 60       	ori	r24, 0x01	; 1
 3b2:	88 bf       	out	0x38, r24	; 56
	TCCR0 = 0x00;
	//setting initial value to 4
	TCNT0 = (1<<2);
	//clkI/O/64 (From prescaler)
	TCCR0 |= 0x03;
	for (int i = 0; i < overflowNum; i++)
 3b4:	2f 5f       	subi	r18, 0xFF	; 255
 3b6:	3f 4f       	sbci	r19, 0xFF	; 255
 3b8:	2e 33       	cpi	r18, 0x3E	; 62
 3ba:	31 05       	cpc	r19, r1
 3bc:	a8 f3       	brcs	.-22     	; 0x3a8 <Delay_1s+0x12>
		//wait until overflow flag to be set
		while((TIFR & (1<<0)) == 0);
		//clear overflow flag
		TIFR |= (1<<0);
	}
}
 3be:	08 95       	ret

000003c0 <Delay>:

//generic delay
void Delay(int sec_num)
{
 3c0:	0f 93       	push	r16
 3c2:	1f 93       	push	r17
 3c4:	cf 93       	push	r28
 3c6:	df 93       	push	r29
 3c8:	8c 01       	movw	r16, r24
	for (int i = 0; i < sec_num; i++)
 3ca:	c0 e0       	ldi	r28, 0x00	; 0
 3cc:	d0 e0       	ldi	r29, 0x00	; 0
 3ce:	03 c0       	rjmp	.+6      	; 0x3d6 <Delay+0x16>
	{
		Delay_1s();
 3d0:	0e 94 cb 01 	call	0x396	; 0x396 <Delay_1s>
}

//generic delay
void Delay(int sec_num)
{
	for (int i = 0; i < sec_num; i++)
 3d4:	21 96       	adiw	r28, 0x01	; 1
 3d6:	c0 17       	cp	r28, r16
 3d8:	d1 07       	cpc	r29, r17
 3da:	d4 f3       	brlt	.-12     	; 0x3d0 <Delay+0x10>
	{
		Delay_1s();
	}
}
 3dc:	df 91       	pop	r29
 3de:	cf 91       	pop	r28
 3e0:	1f 91       	pop	r17
 3e2:	0f 91       	pop	r16
 3e4:	08 95       	ret

000003e6 <main>:
uint8_t Button_state = 0;


int main(void)
{
	APP_init();
 3e6:	0e 94 3e 00 	call	0x7c	; 0x7c <APP_init>
    while (1) 
    {
		APP_start();
 3ea:	0e 94 5d 00 	call	0xba	; 0xba <APP_start>
 3ee:	fd cf       	rjmp	.-6      	; 0x3ea <main+0x4>

000003f0 <DIO_init>:


//functions implementation
EN_DioError_t DIO_init(uint8_t port_name, uint8_t pin_number, uint8_t direction)
{
	if (pin_number >= NumOfPins)
 3f0:	68 30       	cpi	r22, 0x08	; 8
 3f2:	08 f0       	brcs	.+2      	; 0x3f6 <DIO_init+0x6>
 3f4:	83 c0       	rjmp	.+262    	; 0x4fc <__EEPROM_REGION_LENGTH__+0xfc>
	{
		return Wrong_pinNum;
	}
	switch(port_name)
 3f6:	82 34       	cpi	r24, 0x42	; 66
 3f8:	49 f1       	breq	.+82     	; 0x44c <__EEPROM_REGION_LENGTH__+0x4c>
 3fa:	18 f4       	brcc	.+6      	; 0x402 <__EEPROM_REGION_LENGTH__+0x2>
 3fc:	81 34       	cpi	r24, 0x41	; 65
 3fe:	41 f0       	breq	.+16     	; 0x410 <__EEPROM_REGION_LENGTH__+0x10>
 400:	7f c0       	rjmp	.+254    	; 0x500 <__EEPROM_REGION_LENGTH__+0x100>
 402:	83 34       	cpi	r24, 0x43	; 67
 404:	09 f4       	brne	.+2      	; 0x408 <__EEPROM_REGION_LENGTH__+0x8>
 406:	40 c0       	rjmp	.+128    	; 0x488 <__EEPROM_REGION_LENGTH__+0x88>
 408:	84 34       	cpi	r24, 0x44	; 68
 40a:	09 f4       	brne	.+2      	; 0x40e <__EEPROM_REGION_LENGTH__+0xe>
 40c:	5a c0       	rjmp	.+180    	; 0x4c2 <__EEPROM_REGION_LENGTH__+0xc2>
 40e:	78 c0       	rjmp	.+240    	; 0x500 <__EEPROM_REGION_LENGTH__+0x100>
	{
		case PORT_A:
		if (direction == INPUT)
 410:	41 11       	cpse	r20, r1
 412:	0d c0       	rjmp	.+26     	; 0x42e <__EEPROM_REGION_LENGTH__+0x2e>
		{
			DDRA &= ~(1<<pin_number);
 414:	2a b3       	in	r18, 0x1a	; 26
 416:	81 e0       	ldi	r24, 0x01	; 1
 418:	90 e0       	ldi	r25, 0x00	; 0
 41a:	02 c0       	rjmp	.+4      	; 0x420 <__EEPROM_REGION_LENGTH__+0x20>
 41c:	88 0f       	add	r24, r24
 41e:	99 1f       	adc	r25, r25
 420:	6a 95       	dec	r22
 422:	e2 f7       	brpl	.-8      	; 0x41c <__EEPROM_REGION_LENGTH__+0x1c>
 424:	80 95       	com	r24
 426:	82 23       	and	r24, r18
 428:	8a bb       	out	0x1a, r24	; 26
			return OK;
 42a:	80 e0       	ldi	r24, 0x00	; 0
 42c:	08 95       	ret
		}
		else if (direction == OUTPUT)
 42e:	41 30       	cpi	r20, 0x01	; 1
 430:	09 f0       	breq	.+2      	; 0x434 <__EEPROM_REGION_LENGTH__+0x34>
 432:	68 c0       	rjmp	.+208    	; 0x504 <__EEPROM_REGION_LENGTH__+0x104>
		{
			DDRA |= (1<<pin_number);
 434:	2a b3       	in	r18, 0x1a	; 26
 436:	81 e0       	ldi	r24, 0x01	; 1
 438:	90 e0       	ldi	r25, 0x00	; 0
 43a:	02 c0       	rjmp	.+4      	; 0x440 <__EEPROM_REGION_LENGTH__+0x40>
 43c:	88 0f       	add	r24, r24
 43e:	99 1f       	adc	r25, r25
 440:	6a 95       	dec	r22
 442:	e2 f7       	brpl	.-8      	; 0x43c <__EEPROM_REGION_LENGTH__+0x3c>
 444:	82 2b       	or	r24, r18
 446:	8a bb       	out	0x1a, r24	; 26
			return OK;
 448:	80 e0       	ldi	r24, 0x00	; 0
 44a:	08 95       	ret
			return WRONG_Direction;
		}
		break;

		case PORT_B:
		if (direction == INPUT)
 44c:	41 11       	cpse	r20, r1
 44e:	0d c0       	rjmp	.+26     	; 0x46a <__EEPROM_REGION_LENGTH__+0x6a>
		{
			DDRB &= ~(1<<pin_number);
 450:	27 b3       	in	r18, 0x17	; 23
 452:	81 e0       	ldi	r24, 0x01	; 1
 454:	90 e0       	ldi	r25, 0x00	; 0
 456:	02 c0       	rjmp	.+4      	; 0x45c <__EEPROM_REGION_LENGTH__+0x5c>
 458:	88 0f       	add	r24, r24
 45a:	99 1f       	adc	r25, r25
 45c:	6a 95       	dec	r22
 45e:	e2 f7       	brpl	.-8      	; 0x458 <__EEPROM_REGION_LENGTH__+0x58>
 460:	80 95       	com	r24
 462:	82 23       	and	r24, r18
 464:	87 bb       	out	0x17, r24	; 23
			return OK;
 466:	80 e0       	ldi	r24, 0x00	; 0
 468:	08 95       	ret
		}
		else if (direction == OUTPUT)
 46a:	41 30       	cpi	r20, 0x01	; 1
 46c:	09 f0       	breq	.+2      	; 0x470 <__EEPROM_REGION_LENGTH__+0x70>
 46e:	4c c0       	rjmp	.+152    	; 0x508 <__EEPROM_REGION_LENGTH__+0x108>
		{
			DDRB |= (1<<pin_number);
 470:	27 b3       	in	r18, 0x17	; 23
 472:	81 e0       	ldi	r24, 0x01	; 1
 474:	90 e0       	ldi	r25, 0x00	; 0
 476:	02 c0       	rjmp	.+4      	; 0x47c <__EEPROM_REGION_LENGTH__+0x7c>
 478:	88 0f       	add	r24, r24
 47a:	99 1f       	adc	r25, r25
 47c:	6a 95       	dec	r22
 47e:	e2 f7       	brpl	.-8      	; 0x478 <__EEPROM_REGION_LENGTH__+0x78>
 480:	82 2b       	or	r24, r18
 482:	87 bb       	out	0x17, r24	; 23
			return OK;
 484:	80 e0       	ldi	r24, 0x00	; 0
 486:	08 95       	ret
			return WRONG_Direction;
		}
		break;
		
		case PORT_C:
		if (direction == INPUT)
 488:	41 11       	cpse	r20, r1
 48a:	0d c0       	rjmp	.+26     	; 0x4a6 <__EEPROM_REGION_LENGTH__+0xa6>
		{
			DDRC &= ~(1<<pin_number);
 48c:	24 b3       	in	r18, 0x14	; 20
 48e:	81 e0       	ldi	r24, 0x01	; 1
 490:	90 e0       	ldi	r25, 0x00	; 0
 492:	02 c0       	rjmp	.+4      	; 0x498 <__EEPROM_REGION_LENGTH__+0x98>
 494:	88 0f       	add	r24, r24
 496:	99 1f       	adc	r25, r25
 498:	6a 95       	dec	r22
 49a:	e2 f7       	brpl	.-8      	; 0x494 <__EEPROM_REGION_LENGTH__+0x94>
 49c:	80 95       	com	r24
 49e:	82 23       	and	r24, r18
 4a0:	84 bb       	out	0x14, r24	; 20
			return OK;
 4a2:	80 e0       	ldi	r24, 0x00	; 0
 4a4:	08 95       	ret
		}
		else if (direction == OUTPUT)
 4a6:	41 30       	cpi	r20, 0x01	; 1
 4a8:	89 f5       	brne	.+98     	; 0x50c <__EEPROM_REGION_LENGTH__+0x10c>
		{
			DDRC |= (1<<pin_number);
 4aa:	24 b3       	in	r18, 0x14	; 20
 4ac:	81 e0       	ldi	r24, 0x01	; 1
 4ae:	90 e0       	ldi	r25, 0x00	; 0
 4b0:	02 c0       	rjmp	.+4      	; 0x4b6 <__EEPROM_REGION_LENGTH__+0xb6>
 4b2:	88 0f       	add	r24, r24
 4b4:	99 1f       	adc	r25, r25
 4b6:	6a 95       	dec	r22
 4b8:	e2 f7       	brpl	.-8      	; 0x4b2 <__EEPROM_REGION_LENGTH__+0xb2>
 4ba:	82 2b       	or	r24, r18
 4bc:	84 bb       	out	0x14, r24	; 20
			return OK;
 4be:	80 e0       	ldi	r24, 0x00	; 0
 4c0:	08 95       	ret
			return WRONG_Direction;
		}
		break;
		
		case PORT_D:
		if (direction == INPUT)
 4c2:	41 11       	cpse	r20, r1
 4c4:	0d c0       	rjmp	.+26     	; 0x4e0 <__EEPROM_REGION_LENGTH__+0xe0>
		{
			DDRD &= ~(1<<pin_number);
 4c6:	21 b3       	in	r18, 0x11	; 17
 4c8:	81 e0       	ldi	r24, 0x01	; 1
 4ca:	90 e0       	ldi	r25, 0x00	; 0
 4cc:	02 c0       	rjmp	.+4      	; 0x4d2 <__EEPROM_REGION_LENGTH__+0xd2>
 4ce:	88 0f       	add	r24, r24
 4d0:	99 1f       	adc	r25, r25
 4d2:	6a 95       	dec	r22
 4d4:	e2 f7       	brpl	.-8      	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
 4d6:	80 95       	com	r24
 4d8:	82 23       	and	r24, r18
 4da:	81 bb       	out	0x11, r24	; 17
			return OK;
 4dc:	80 e0       	ldi	r24, 0x00	; 0
 4de:	08 95       	ret
		}
		else if (direction == OUTPUT)
 4e0:	41 30       	cpi	r20, 0x01	; 1
 4e2:	b1 f4       	brne	.+44     	; 0x510 <__EEPROM_REGION_LENGTH__+0x110>
		{
			DDRD |= (1<<pin_number);
 4e4:	21 b3       	in	r18, 0x11	; 17
 4e6:	81 e0       	ldi	r24, 0x01	; 1
 4e8:	90 e0       	ldi	r25, 0x00	; 0
 4ea:	02 c0       	rjmp	.+4      	; 0x4f0 <__EEPROM_REGION_LENGTH__+0xf0>
 4ec:	88 0f       	add	r24, r24
 4ee:	99 1f       	adc	r25, r25
 4f0:	6a 95       	dec	r22
 4f2:	e2 f7       	brpl	.-8      	; 0x4ec <__EEPROM_REGION_LENGTH__+0xec>
 4f4:	82 2b       	or	r24, r18
 4f6:	81 bb       	out	0x11, r24	; 17
			return OK;
 4f8:	80 e0       	ldi	r24, 0x00	; 0
 4fa:	08 95       	ret
//functions implementation
EN_DioError_t DIO_init(uint8_t port_name, uint8_t pin_number, uint8_t direction)
{
	if (pin_number >= NumOfPins)
	{
		return Wrong_pinNum;
 4fc:	83 e0       	ldi	r24, 0x03	; 3
 4fe:	08 95       	ret
			return WRONG_Direction;
		}
		break;
		
		default:
		return Wrong_portName;
 500:	82 e0       	ldi	r24, 0x02	; 2
 502:	08 95       	ret
			DDRA |= (1<<pin_number);
			return OK;
		}
		else
		{
			return WRONG_Direction;
 504:	81 e0       	ldi	r24, 0x01	; 1
 506:	08 95       	ret
			DDRB |= (1<<pin_number);
			return OK;
		}
		else
		{
			return WRONG_Direction;
 508:	81 e0       	ldi	r24, 0x01	; 1
 50a:	08 95       	ret
			DDRC |= (1<<pin_number);
			return OK;
		}
		else
		{
			return WRONG_Direction;
 50c:	81 e0       	ldi	r24, 0x01	; 1
 50e:	08 95       	ret
			DDRD |= (1<<pin_number);
			return OK;
		}
		else
		{
			return WRONG_Direction;
 510:	81 e0       	ldi	r24, 0x01	; 1
		break;
		
		default:
		return Wrong_portName;
	}
}
 512:	08 95       	ret

00000514 <DIO_write>:

EN_DioError_t DIO_write(uint8_t port_name, uint8_t pin_number, uint8_t value)
{
	if (pin_number >= NumOfPins)
 514:	68 30       	cpi	r22, 0x08	; 8
 516:	08 f0       	brcs	.+2      	; 0x51a <DIO_write+0x6>
 518:	83 c0       	rjmp	.+262    	; 0x620 <DIO_write+0x10c>
	{
		return Wrong_pinNum;
	}
	switch(port_name)
 51a:	82 34       	cpi	r24, 0x42	; 66
 51c:	49 f1       	breq	.+82     	; 0x570 <DIO_write+0x5c>
 51e:	18 f4       	brcc	.+6      	; 0x526 <DIO_write+0x12>
 520:	81 34       	cpi	r24, 0x41	; 65
 522:	41 f0       	breq	.+16     	; 0x534 <DIO_write+0x20>
 524:	7f c0       	rjmp	.+254    	; 0x624 <DIO_write+0x110>
 526:	83 34       	cpi	r24, 0x43	; 67
 528:	09 f4       	brne	.+2      	; 0x52c <DIO_write+0x18>
 52a:	40 c0       	rjmp	.+128    	; 0x5ac <DIO_write+0x98>
 52c:	84 34       	cpi	r24, 0x44	; 68
 52e:	09 f4       	brne	.+2      	; 0x532 <DIO_write+0x1e>
 530:	5a c0       	rjmp	.+180    	; 0x5e6 <DIO_write+0xd2>
 532:	78 c0       	rjmp	.+240    	; 0x624 <DIO_write+0x110>
	{
		case PORT_A:
		if (value == LOW)
 534:	41 11       	cpse	r20, r1
 536:	0d c0       	rjmp	.+26     	; 0x552 <DIO_write+0x3e>
		{
			PORTA &= ~(1<<pin_number);
 538:	2b b3       	in	r18, 0x1b	; 27
 53a:	81 e0       	ldi	r24, 0x01	; 1
 53c:	90 e0       	ldi	r25, 0x00	; 0
 53e:	02 c0       	rjmp	.+4      	; 0x544 <DIO_write+0x30>
 540:	88 0f       	add	r24, r24
 542:	99 1f       	adc	r25, r25
 544:	6a 95       	dec	r22
 546:	e2 f7       	brpl	.-8      	; 0x540 <DIO_write+0x2c>
 548:	80 95       	com	r24
 54a:	82 23       	and	r24, r18
 54c:	8b bb       	out	0x1b, r24	; 27
			return OK;
 54e:	80 e0       	ldi	r24, 0x00	; 0
 550:	08 95       	ret
		}
		else if (value == HIGH)
 552:	41 30       	cpi	r20, 0x01	; 1
 554:	09 f0       	breq	.+2      	; 0x558 <DIO_write+0x44>
 556:	68 c0       	rjmp	.+208    	; 0x628 <DIO_write+0x114>
		{
			PORTA |= (1<<pin_number);
 558:	2b b3       	in	r18, 0x1b	; 27
 55a:	81 e0       	ldi	r24, 0x01	; 1
 55c:	90 e0       	ldi	r25, 0x00	; 0
 55e:	02 c0       	rjmp	.+4      	; 0x564 <DIO_write+0x50>
 560:	88 0f       	add	r24, r24
 562:	99 1f       	adc	r25, r25
 564:	6a 95       	dec	r22
 566:	e2 f7       	brpl	.-8      	; 0x560 <DIO_write+0x4c>
 568:	82 2b       	or	r24, r18
 56a:	8b bb       	out	0x1b, r24	; 27
			return OK;
 56c:	80 e0       	ldi	r24, 0x00	; 0
 56e:	08 95       	ret
			return WRONG_Direction;
		}
		break;

		case PORT_B:
		if (value == LOW)
 570:	41 11       	cpse	r20, r1
 572:	0d c0       	rjmp	.+26     	; 0x58e <DIO_write+0x7a>
		{
			PORTB &= ~(1<<pin_number);
 574:	28 b3       	in	r18, 0x18	; 24
 576:	81 e0       	ldi	r24, 0x01	; 1
 578:	90 e0       	ldi	r25, 0x00	; 0
 57a:	02 c0       	rjmp	.+4      	; 0x580 <DIO_write+0x6c>
 57c:	88 0f       	add	r24, r24
 57e:	99 1f       	adc	r25, r25
 580:	6a 95       	dec	r22
 582:	e2 f7       	brpl	.-8      	; 0x57c <DIO_write+0x68>
 584:	80 95       	com	r24
 586:	82 23       	and	r24, r18
 588:	88 bb       	out	0x18, r24	; 24
			return OK;
 58a:	80 e0       	ldi	r24, 0x00	; 0
 58c:	08 95       	ret
		}
		else if (value == HIGH)
 58e:	41 30       	cpi	r20, 0x01	; 1
 590:	09 f0       	breq	.+2      	; 0x594 <DIO_write+0x80>
 592:	4c c0       	rjmp	.+152    	; 0x62c <DIO_write+0x118>
		{
			PORTB |= (1<<pin_number);
 594:	28 b3       	in	r18, 0x18	; 24
 596:	81 e0       	ldi	r24, 0x01	; 1
 598:	90 e0       	ldi	r25, 0x00	; 0
 59a:	02 c0       	rjmp	.+4      	; 0x5a0 <DIO_write+0x8c>
 59c:	88 0f       	add	r24, r24
 59e:	99 1f       	adc	r25, r25
 5a0:	6a 95       	dec	r22
 5a2:	e2 f7       	brpl	.-8      	; 0x59c <DIO_write+0x88>
 5a4:	82 2b       	or	r24, r18
 5a6:	88 bb       	out	0x18, r24	; 24
			return OK;
 5a8:	80 e0       	ldi	r24, 0x00	; 0
 5aa:	08 95       	ret
			return WRONG_Direction;
		}
		break;
		
		case PORT_C:
		if (value == LOW)
 5ac:	41 11       	cpse	r20, r1
 5ae:	0d c0       	rjmp	.+26     	; 0x5ca <DIO_write+0xb6>
		{
			PORTC &= ~(1<<pin_number);
 5b0:	25 b3       	in	r18, 0x15	; 21
 5b2:	81 e0       	ldi	r24, 0x01	; 1
 5b4:	90 e0       	ldi	r25, 0x00	; 0
 5b6:	02 c0       	rjmp	.+4      	; 0x5bc <DIO_write+0xa8>
 5b8:	88 0f       	add	r24, r24
 5ba:	99 1f       	adc	r25, r25
 5bc:	6a 95       	dec	r22
 5be:	e2 f7       	brpl	.-8      	; 0x5b8 <DIO_write+0xa4>
 5c0:	80 95       	com	r24
 5c2:	82 23       	and	r24, r18
 5c4:	85 bb       	out	0x15, r24	; 21
			return OK;
 5c6:	80 e0       	ldi	r24, 0x00	; 0
 5c8:	08 95       	ret
		}
		else if (value == HIGH)
 5ca:	41 30       	cpi	r20, 0x01	; 1
 5cc:	89 f5       	brne	.+98     	; 0x630 <DIO_write+0x11c>
		{
			PORTC |= (1<<pin_number);
 5ce:	25 b3       	in	r18, 0x15	; 21
 5d0:	81 e0       	ldi	r24, 0x01	; 1
 5d2:	90 e0       	ldi	r25, 0x00	; 0
 5d4:	02 c0       	rjmp	.+4      	; 0x5da <DIO_write+0xc6>
 5d6:	88 0f       	add	r24, r24
 5d8:	99 1f       	adc	r25, r25
 5da:	6a 95       	dec	r22
 5dc:	e2 f7       	brpl	.-8      	; 0x5d6 <DIO_write+0xc2>
 5de:	82 2b       	or	r24, r18
 5e0:	85 bb       	out	0x15, r24	; 21
			return OK;
 5e2:	80 e0       	ldi	r24, 0x00	; 0
 5e4:	08 95       	ret
			return WRONG_Direction;
		}
		break;
		
		case PORT_D:
		if (value == LOW)
 5e6:	41 11       	cpse	r20, r1
 5e8:	0d c0       	rjmp	.+26     	; 0x604 <DIO_write+0xf0>
		{
			PORTD &= ~(1<<pin_number);
 5ea:	22 b3       	in	r18, 0x12	; 18
 5ec:	81 e0       	ldi	r24, 0x01	; 1
 5ee:	90 e0       	ldi	r25, 0x00	; 0
 5f0:	02 c0       	rjmp	.+4      	; 0x5f6 <DIO_write+0xe2>
 5f2:	88 0f       	add	r24, r24
 5f4:	99 1f       	adc	r25, r25
 5f6:	6a 95       	dec	r22
 5f8:	e2 f7       	brpl	.-8      	; 0x5f2 <DIO_write+0xde>
 5fa:	80 95       	com	r24
 5fc:	82 23       	and	r24, r18
 5fe:	82 bb       	out	0x12, r24	; 18
			return OK;
 600:	80 e0       	ldi	r24, 0x00	; 0
 602:	08 95       	ret
		}
		else if (value == HIGH)
 604:	41 30       	cpi	r20, 0x01	; 1
 606:	b1 f4       	brne	.+44     	; 0x634 <DIO_write+0x120>
		{
			PORTD |= (1<<pin_number);
 608:	22 b3       	in	r18, 0x12	; 18
 60a:	81 e0       	ldi	r24, 0x01	; 1
 60c:	90 e0       	ldi	r25, 0x00	; 0
 60e:	02 c0       	rjmp	.+4      	; 0x614 <DIO_write+0x100>
 610:	88 0f       	add	r24, r24
 612:	99 1f       	adc	r25, r25
 614:	6a 95       	dec	r22
 616:	e2 f7       	brpl	.-8      	; 0x610 <DIO_write+0xfc>
 618:	82 2b       	or	r24, r18
 61a:	82 bb       	out	0x12, r24	; 18
			return OK;
 61c:	80 e0       	ldi	r24, 0x00	; 0
 61e:	08 95       	ret

EN_DioError_t DIO_write(uint8_t port_name, uint8_t pin_number, uint8_t value)
{
	if (pin_number >= NumOfPins)
	{
		return Wrong_pinNum;
 620:	83 e0       	ldi	r24, 0x03	; 3
 622:	08 95       	ret
			return WRONG_Direction;
		}
		break;
		
		default:
		return Wrong_portName;
 624:	82 e0       	ldi	r24, 0x02	; 2
 626:	08 95       	ret
			PORTA |= (1<<pin_number);
			return OK;
		}
		else
		{
			return WRONG_Direction;
 628:	81 e0       	ldi	r24, 0x01	; 1
 62a:	08 95       	ret
			PORTB |= (1<<pin_number);
			return OK;
		}
		else
		{
			return WRONG_Direction;
 62c:	81 e0       	ldi	r24, 0x01	; 1
 62e:	08 95       	ret
			PORTC |= (1<<pin_number);
			return OK;
		}
		else
		{
			return WRONG_Direction;
 630:	81 e0       	ldi	r24, 0x01	; 1
 632:	08 95       	ret
			PORTD |= (1<<pin_number);
			return OK;
		}
		else
		{
			return WRONG_Direction;
 634:	81 e0       	ldi	r24, 0x01	; 1
		break;
		
		default:
		return Wrong_portName;
	}
}
 636:	08 95       	ret

00000638 <DIO_Read>:

EN_DioError_t DIO_Read(uint8_t port_name, uint8_t pin_number, uint8_t *value)
{
	if (pin_number >= NumOfPins)
 638:	68 30       	cpi	r22, 0x08	; 8
 63a:	08 f0       	brcs	.+2      	; 0x63e <DIO_Read+0x6>
 63c:	68 c0       	rjmp	.+208    	; 0x70e <DIO_Read+0xd6>
	{
		return Wrong_pinNum;
	}
	switch(port_name)
 63e:	82 34       	cpi	r24, 0x42	; 66
 640:	09 f1       	breq	.+66     	; 0x684 <DIO_Read+0x4c>
 642:	18 f4       	brcc	.+6      	; 0x64a <DIO_Read+0x12>
 644:	81 34       	cpi	r24, 0x41	; 65
 646:	39 f0       	breq	.+14     	; 0x656 <DIO_Read+0x1e>
 648:	64 c0       	rjmp	.+200    	; 0x712 <DIO_Read+0xda>
 64a:	83 34       	cpi	r24, 0x43	; 67
 64c:	91 f1       	breq	.+100    	; 0x6b2 <DIO_Read+0x7a>
 64e:	84 34       	cpi	r24, 0x44	; 68
 650:	09 f4       	brne	.+2      	; 0x654 <DIO_Read+0x1c>
 652:	46 c0       	rjmp	.+140    	; 0x6e0 <DIO_Read+0xa8>
 654:	5e c0       	rjmp	.+188    	; 0x712 <DIO_Read+0xda>
	{
		case PORT_A:
		*value = ((PINA & (1 << pin_number)) >> pin_number);
 656:	79 b3       	in	r23, 0x19	; 25
 658:	81 e0       	ldi	r24, 0x01	; 1
 65a:	90 e0       	ldi	r25, 0x00	; 0
 65c:	9c 01       	movw	r18, r24
 65e:	06 2e       	mov	r0, r22
 660:	02 c0       	rjmp	.+4      	; 0x666 <DIO_Read+0x2e>
 662:	22 0f       	add	r18, r18
 664:	33 1f       	adc	r19, r19
 666:	0a 94       	dec	r0
 668:	e2 f7       	brpl	.-8      	; 0x662 <DIO_Read+0x2a>
 66a:	87 2f       	mov	r24, r23
 66c:	90 e0       	ldi	r25, 0x00	; 0
 66e:	82 23       	and	r24, r18
 670:	93 23       	and	r25, r19
 672:	02 c0       	rjmp	.+4      	; 0x678 <DIO_Read+0x40>
 674:	95 95       	asr	r25
 676:	87 95       	ror	r24
 678:	6a 95       	dec	r22
 67a:	e2 f7       	brpl	.-8      	; 0x674 <DIO_Read+0x3c>
 67c:	fa 01       	movw	r30, r20
 67e:	80 83       	st	Z, r24
		return OK;
 680:	80 e0       	ldi	r24, 0x00	; 0
 682:	08 95       	ret
		break;
		
		case PORT_B:
		*value = ((PINB & (1 << pin_number)) >> pin_number);
 684:	76 b3       	in	r23, 0x16	; 22
 686:	81 e0       	ldi	r24, 0x01	; 1
 688:	90 e0       	ldi	r25, 0x00	; 0
 68a:	9c 01       	movw	r18, r24
 68c:	06 2e       	mov	r0, r22
 68e:	02 c0       	rjmp	.+4      	; 0x694 <DIO_Read+0x5c>
 690:	22 0f       	add	r18, r18
 692:	33 1f       	adc	r19, r19
 694:	0a 94       	dec	r0
 696:	e2 f7       	brpl	.-8      	; 0x690 <DIO_Read+0x58>
 698:	87 2f       	mov	r24, r23
 69a:	90 e0       	ldi	r25, 0x00	; 0
 69c:	82 23       	and	r24, r18
 69e:	93 23       	and	r25, r19
 6a0:	02 c0       	rjmp	.+4      	; 0x6a6 <DIO_Read+0x6e>
 6a2:	95 95       	asr	r25
 6a4:	87 95       	ror	r24
 6a6:	6a 95       	dec	r22
 6a8:	e2 f7       	brpl	.-8      	; 0x6a2 <DIO_Read+0x6a>
 6aa:	fa 01       	movw	r30, r20
 6ac:	80 83       	st	Z, r24
		return OK;
 6ae:	80 e0       	ldi	r24, 0x00	; 0
 6b0:	08 95       	ret
		break;
		
		case PORT_C:
		*value = ((PINC & (1 << pin_number)) >> pin_number);
 6b2:	73 b3       	in	r23, 0x13	; 19
 6b4:	81 e0       	ldi	r24, 0x01	; 1
 6b6:	90 e0       	ldi	r25, 0x00	; 0
 6b8:	9c 01       	movw	r18, r24
 6ba:	06 2e       	mov	r0, r22
 6bc:	02 c0       	rjmp	.+4      	; 0x6c2 <DIO_Read+0x8a>
 6be:	22 0f       	add	r18, r18
 6c0:	33 1f       	adc	r19, r19
 6c2:	0a 94       	dec	r0
 6c4:	e2 f7       	brpl	.-8      	; 0x6be <DIO_Read+0x86>
 6c6:	87 2f       	mov	r24, r23
 6c8:	90 e0       	ldi	r25, 0x00	; 0
 6ca:	82 23       	and	r24, r18
 6cc:	93 23       	and	r25, r19
 6ce:	02 c0       	rjmp	.+4      	; 0x6d4 <DIO_Read+0x9c>
 6d0:	95 95       	asr	r25
 6d2:	87 95       	ror	r24
 6d4:	6a 95       	dec	r22
 6d6:	e2 f7       	brpl	.-8      	; 0x6d0 <DIO_Read+0x98>
 6d8:	fa 01       	movw	r30, r20
 6da:	80 83       	st	Z, r24
		return OK;
 6dc:	80 e0       	ldi	r24, 0x00	; 0
 6de:	08 95       	ret
		break;
		
		case PORT_D:
		*value = ((PIND & (1 << pin_number)) >> pin_number);
 6e0:	70 b3       	in	r23, 0x10	; 16
 6e2:	81 e0       	ldi	r24, 0x01	; 1
 6e4:	90 e0       	ldi	r25, 0x00	; 0
 6e6:	9c 01       	movw	r18, r24
 6e8:	06 2e       	mov	r0, r22
 6ea:	02 c0       	rjmp	.+4      	; 0x6f0 <DIO_Read+0xb8>
 6ec:	22 0f       	add	r18, r18
 6ee:	33 1f       	adc	r19, r19
 6f0:	0a 94       	dec	r0
 6f2:	e2 f7       	brpl	.-8      	; 0x6ec <DIO_Read+0xb4>
 6f4:	87 2f       	mov	r24, r23
 6f6:	90 e0       	ldi	r25, 0x00	; 0
 6f8:	82 23       	and	r24, r18
 6fa:	93 23       	and	r25, r19
 6fc:	02 c0       	rjmp	.+4      	; 0x702 <DIO_Read+0xca>
 6fe:	95 95       	asr	r25
 700:	87 95       	ror	r24
 702:	6a 95       	dec	r22
 704:	e2 f7       	brpl	.-8      	; 0x6fe <DIO_Read+0xc6>
 706:	fa 01       	movw	r30, r20
 708:	80 83       	st	Z, r24
		return OK;
 70a:	80 e0       	ldi	r24, 0x00	; 0
 70c:	08 95       	ret

EN_DioError_t DIO_Read(uint8_t port_name, uint8_t pin_number, uint8_t *value)
{
	if (pin_number >= NumOfPins)
	{
		return Wrong_pinNum;
 70e:	83 e0       	ldi	r24, 0x03	; 3
 710:	08 95       	ret
		*value = ((PIND & (1 << pin_number)) >> pin_number);
		return OK;
		break;
		
		default:
		return Wrong_portName;
 712:	82 e0       	ldi	r24, 0x02	; 2
	}
}
 714:	08 95       	ret

00000716 <DIO_toggle>:

EN_DioError_t DIO_toggle(uint8_t port_name, uint8_t pin_number)
{
	if (pin_number >= NumOfPins)
 716:	68 30       	cpi	r22, 0x08	; 8
 718:	d8 f5       	brcc	.+118    	; 0x790 <DIO_toggle+0x7a>
	{
		return Wrong_pinNum;
	}
	switch(port_name){
 71a:	82 34       	cpi	r24, 0x42	; 66
 71c:	a9 f0       	breq	.+42     	; 0x748 <DIO_toggle+0x32>
 71e:	18 f4       	brcc	.+6      	; 0x726 <DIO_toggle+0x10>
 720:	81 34       	cpi	r24, 0x41	; 65
 722:	31 f0       	breq	.+12     	; 0x730 <DIO_toggle+0x1a>
 724:	37 c0       	rjmp	.+110    	; 0x794 <DIO_toggle+0x7e>
 726:	83 34       	cpi	r24, 0x43	; 67
 728:	d9 f0       	breq	.+54     	; 0x760 <DIO_toggle+0x4a>
 72a:	84 34       	cpi	r24, 0x44	; 68
 72c:	29 f1       	breq	.+74     	; 0x778 <DIO_toggle+0x62>
 72e:	32 c0       	rjmp	.+100    	; 0x794 <DIO_toggle+0x7e>
		case PORT_A:
		PORTA ^= (1<<pin_number);
 730:	2b b3       	in	r18, 0x1b	; 27
 732:	81 e0       	ldi	r24, 0x01	; 1
 734:	90 e0       	ldi	r25, 0x00	; 0
 736:	02 c0       	rjmp	.+4      	; 0x73c <DIO_toggle+0x26>
 738:	88 0f       	add	r24, r24
 73a:	99 1f       	adc	r25, r25
 73c:	6a 95       	dec	r22
 73e:	e2 f7       	brpl	.-8      	; 0x738 <DIO_toggle+0x22>
 740:	82 27       	eor	r24, r18
 742:	8b bb       	out	0x1b, r24	; 27
		return OK;
 744:	80 e0       	ldi	r24, 0x00	; 0
 746:	08 95       	ret
		break;
		case PORT_B:
		PORTB ^= (1<<pin_number);
 748:	28 b3       	in	r18, 0x18	; 24
 74a:	81 e0       	ldi	r24, 0x01	; 1
 74c:	90 e0       	ldi	r25, 0x00	; 0
 74e:	02 c0       	rjmp	.+4      	; 0x754 <DIO_toggle+0x3e>
 750:	88 0f       	add	r24, r24
 752:	99 1f       	adc	r25, r25
 754:	6a 95       	dec	r22
 756:	e2 f7       	brpl	.-8      	; 0x750 <DIO_toggle+0x3a>
 758:	82 27       	eor	r24, r18
 75a:	88 bb       	out	0x18, r24	; 24
		return OK;
 75c:	80 e0       	ldi	r24, 0x00	; 0
 75e:	08 95       	ret
		break;
		case PORT_C:
		PORTC ^= (1<<pin_number);
 760:	25 b3       	in	r18, 0x15	; 21
 762:	81 e0       	ldi	r24, 0x01	; 1
 764:	90 e0       	ldi	r25, 0x00	; 0
 766:	02 c0       	rjmp	.+4      	; 0x76c <DIO_toggle+0x56>
 768:	88 0f       	add	r24, r24
 76a:	99 1f       	adc	r25, r25
 76c:	6a 95       	dec	r22
 76e:	e2 f7       	brpl	.-8      	; 0x768 <DIO_toggle+0x52>
 770:	82 27       	eor	r24, r18
 772:	85 bb       	out	0x15, r24	; 21
		return OK;
 774:	80 e0       	ldi	r24, 0x00	; 0
 776:	08 95       	ret
		break;
		case PORT_D:
		PORTD ^= (1<<pin_number);
 778:	22 b3       	in	r18, 0x12	; 18
 77a:	81 e0       	ldi	r24, 0x01	; 1
 77c:	90 e0       	ldi	r25, 0x00	; 0
 77e:	02 c0       	rjmp	.+4      	; 0x784 <DIO_toggle+0x6e>
 780:	88 0f       	add	r24, r24
 782:	99 1f       	adc	r25, r25
 784:	6a 95       	dec	r22
 786:	e2 f7       	brpl	.-8      	; 0x780 <DIO_toggle+0x6a>
 788:	82 27       	eor	r24, r18
 78a:	82 bb       	out	0x12, r24	; 18
		return OK;
 78c:	80 e0       	ldi	r24, 0x00	; 0
 78e:	08 95       	ret

EN_DioError_t DIO_toggle(uint8_t port_name, uint8_t pin_number)
{
	if (pin_number >= NumOfPins)
	{
		return Wrong_pinNum;
 790:	83 e0       	ldi	r24, 0x03	; 3
 792:	08 95       	ret
		case PORT_D:
		PORTD ^= (1<<pin_number);
		return OK;
		break;
		default:
		return Wrong_portName;
 794:	82 e0       	ldi	r24, 0x02	; 2
	}
 796:	08 95       	ret

00000798 <_exit>:
 798:	f8 94       	cli

0000079a <__stop_program>:
 79a:	ff cf       	rjmp	.-2      	; 0x79a <__stop_program>
